blueprint:
  name: Automatic Gate
  domain: automation
  author: etiennec78
  description: |-
    WORK IN PROGRESS, EXPECT BUGS
    **Modular** and **secure** gate automation that **opens your gate** upon leaving or arriving
    Supports up to 10 users driving **simultaneously**
    Manual override : Prioritizes manual actions over the automation, letting you control your gate even while the automation is running
    Security features : Auto-close timer, alert notifications, timeout detection, aborting on vehicle left, aborting if driven near home without entering, keeping gate open while someone else approaches or leaves home
    Various options : Custom gate settings, iBeacon automatic closing, travel time update interval
    Flowchart : [click here](https://miro.com/app/board/uXjVMpH4Tno=/)
    Github : [click here](https://github.com/etiennec78/Home-Automation/tree/master/Automatic%20Gate)
    Discord : etiennec78
  input:
    gate:
      name: ⛩️ Gate
      description: The **switch** or **cover** which controls your **gate**
      selector:
        entity:
          filter:
            domain:
              - switch
              - cover
    lead_time:
      name: 🕓 Lead time
      description: The **lead time** to open the gate **before your arrival** (take your gate movement time & a margin into account)
      default: 75
      selector:
        number:
          min: 10
          max: 300
          unit_of_measurement: seconds
    safety_delay:
      name: 🔒 Auto-close delay
      description: The time the gate will wait before **automatically closing** if you haven't left home or didn't arrive
      default: 7
      selector:
        number:
          min: 2
          max: 30
          unit_of_measurement: minutes
    timeout_delay:
      name: ⌛ Timeout delay
      description: The time the automation will wait before **stopping** if your phone **times out** and doesn't send new position updates, while being in the activation zone
      default: 2
      selector:
        number:
          min: 0.5
          max: 30
          unit_of_measurement: minutes
    persons:
      name: 👤 Tracked users
      description: |-
        Each **user** which should be tracked for **position updates** (same order)
        *Note : If your tracker has report latency (wifi/ble), and you plug Android Auto just after leaving home, your gate could open thinking you are still home*
      selector:
        entity:
          multiple: true
          filter:
            domain: person
    driving_sensors:
      name: 🚗 Driving sensors
      description: Each **driving sensor** which should trigger the automation (same order)
      selector:
        entity:
          multiple: true
          filter:
            domain: binary_sensor
    travel_time_sensors:
      name: ✈️ Travel time sensors
      description: Each **travel time** sensor monitoring each user **time left before arrival** (same order)
      selector:
        entity:
          multiple: true
          filter:
            domain: sensor
            device_class: duration
    proximity_sensors:
      name: 📏 Proximity sensors
      description: Each sensor from the **proximity integration** to calculate user distance from home (same order)
      selector:
        entity:
          multiple: true
          filter:
            integration: proximity
            domain: sensor
            device_class: distance
    notify_devices:
      name: 💬 Notify services
      description: Each **service** of **device to notify** (Find the service ids by going into [Developer tools > Services tab](https://my.home-assistant.io/redirect/developer_states/) > searching for "notify.") (same order)
      selector:
        text:
          multiple: true
          prefix: notify.mobile_app_
    itinerary_sensors:
      name: 🗺️ Itinerary sensors
      description: Each **itinerary input text** helper from the wiki to monitor your **itinerary state** (same order)
      selector:
        entity:
          multiple: true
          filter:
            domain: input_text
    eta_sensor:
      name: 📅 Planned time of opening sensor
      description: An empty **input datetime** helper which will be used to set an **ETA** and plan the **opening of your gate** (see wiki)
      selector:
        entity:
          filter:
            domain: input_datetime
    travel_time_rate:
      name: 🔄 Travel time refresh rate
      description: |-
        **⚠️ Please set a [custom polling interval](https://www.home-assistant.io/integrations/waze_travel_time/#defining-a-custom-polling-interval)**

        Calculate the Travel time & ETA

          - **Continuously** during the whole itinerary (custom refresh interval while away)
          - Only while the vehicle is **near home**
          - Only **once** when the vehicle gets near home

        **"Continuously"** can use more Waze/Maps credits, but can be useful to display a precise ETA on your dashboard when far from home
        **"While near home"** allows to monitor if you drive near home without entering to abort the itinerary, or if there are traffic jams near home to open later (recommended)
        **"Only once"** uses the less amount of credits, but could trigger if you come near your house without entering (not recommended)
      default: While near home
      selector:
        select:
          options:
            - Continuously
            - While near home
            - Once when near home
    continuously_refresh_interval:
      name: ⏳ Continuously refresh interval
      description: Your travel time **refresh interval** while away. Only active with a refresh rate set to **"Continously"**
      default: 5
      selector:
        number:
          min: 1
          max: 60
          unit_of_measurement: minutes
    eta_zone:
      name: 🚀 ETA planning zone
      description: At which **distance** from home should your vehicle start planning its **Estimated Time of Arrival** to **open your gate** ?
      default: 1000
      selector:
        number:
          min: 200
          max: 5000
          unit_of_measurement: meters
    activation_zone:
      name: 🔒 Gate activation zone
      description: At which **maximal distance** from home should your vehicle be able to automatically **open your gate** ? It will automatically **close** if you **leave** this zone
      default: 1200
      selector:
        number:
          min: 300
          max: 5000
          unit_of_measurement: meters
    ble_entities:
      name: 🔎 iBeacon tracker entities (optional)
      description: |-
        Each iBeacon **rssi tracker** entity to monitor
        *Note : Let empty if no ble*
      default: []
      selector:
        entity:
          multiple: true
          filter:
            domain: sensor
            device_class: signal_strength
    ble_scanner_switch:
      name: ⏻ iBeacon scanner activator switch (optional)
      description: |-
        The **switch** you want to use to turn on and off your **iBeacon scanner** when a vehicle is leaving home
        *Note : Let empty if no ble / want to always keep iBeacon running*
      default: ""
      selector:
        entity:
          filter:
            domain: switch
    itinerary_update_title:
      name: 📃🛈 Itinerary status update title
      description: The **title** displayed on the notification you will receive when the **status of your itinerary** changes
      default: "Itinerary 🛈"
      selector:
        text:
    itinerary_canceled_title:
      name: 📃❌ Itinerary canceled title
      description: The **title** displayed on the notification you will receive when your **itinerary gets canceled**
      default: "Itinerary canceled ❌"
      selector:
        text:
    gate_closing_title:
      name: 📃🔒 Gate closing notification title
      description: The **title** displayed on the notification you will receive when your **gate is closing**
      default: "Gate closing 🔒"
      selector:
        text:
    awaiting_title:
      name: 📃💤 Gate awaiting user notification title
      description: |-
        The **title** displayed on the notification you will receive when your gate is **awaiting another user**
        *Note : {{awaiting_persons}} will be replaced by the lists of the users being awaited*
      default: "Gate awaiting {{ awaiting_persons }} 💤"
      selector:
        text:
    itinerary_started_message:
      name: 💬🏁 Itinerary started notification
      description: The **title** displayed on the notification you will receive when your **itinerary starts**
      default: "Your itinerary has been started"
      selector:
        text:
    automatic_closing_message:
      name: 💬🤖 Automatic closing notification
      description: The **title** displayed on the notification you will receive when your gate is **automatically closing**
      default: "Automatic closing of the gate"
      selector:
        text:
          multiline: true
    awaiting_message:
      name: 💬💤 Gate awaiting user notification
      description: The **content** of the notification you will receive when your gate is **awaiting another user**
      default: "The gate will close once all users have entered/exited"
      selector:
        text:
          multiline: true
    vehicle_left_message:
      name: 💬⚠️ Vehicle left notification
      description: The **content** of the notification you will receive if you **leave your vehicle**
      default: "You have left your vehicle"
      selector:
        text:
          multiline: true
    did_not_leave_message:
      name: 💬⚠️ User did not leave notification
      description: |-
        The **content** of the notification you will receive if you **don't leave your home in time**
        *Note : {{safety_delay}} will be replaced by your auto-close delay you have set above*
      default: "The vehicle did not leave home in less than {{ safety_delay }} minutes"
      selector:
        text:
          multiline: true
    did_not_arrive_message:
      name: 💬⚠️ User did not arrive notification
      description: |-
        The **content** of the notification you will receive if you **don't arrive home in time**
        *Note : {{safety_delay}} will be replaced by your auto-close delay you have set above*
      default: "The vehicle did not arrive home in less than {{ safety_delay }} minutes"
      selector:
        text:
          multiline: true
    timed_out_message:
      name: 💬⚠️ Timed out notification
      description: |-
        The **content** of the notification you will receive if you **time out**
        *Note : {{timeout_delay}} will be replaced by your auto-close delay you have set above*
      default: "Your position has not been updated in {{ timeout_delay }} minutes"
      selector:
        text:
          multiline: true
    vehicle_away_message:
      name: 💬⚠️ Vehicle not in activation zone notification
      description: The **content** of the notification you will receive if **you are not in your activation zone**
      default: "The vehicle is not in the activation zone"
      selector:
        text:
          multiline: true

variables:
  gate: !input gate
  lead_time: !input lead_time
  safety_delay: !input safety_delay
  timeout_delay: !input timeout_delay
  persons: !input persons
  driving_sensors: !input driving_sensors
  travel_time_sensors: !input travel_time_sensors
  proximity_sensors: !input proximity_sensors
  notify_devices: !input notify_devices
  itinerary_sensors: !input itinerary_sensors
  eta_sensor: !input eta_sensor
  travel_time_rate: !input travel_time_rate
  continuously_refresh_interval: !input continuously_refresh_interval
  eta_zone: !input eta_zone
  activation_zone: !input activation_zone
  ble_entities: !input ble_entities

trigger:
  # Triggers when one of the users connect to a vehicle (if you have more than one, make a custom vehcle sensor : example in configuration.yaml)
  - platform: state
    entity_id: !input driving_sensors
    from: "off"
    to: "on"

condition: []

action:
  # Store the list index of the user who triggered the automation, and extract the recurrent sensors at this index of the list
  - variables:
      idx: "{{ driving_sensors.index(trigger.entity_id) }}"
      person: "{{ persons[idx] }}"
      driving_sensor: "{{ trigger.entity_id }}"
      travel_time_sensor: "{{ travel_time_sensors[idx] }}"
      notify_device: "{{ 'notify.mobile_app_'+notify_devices[idx] }}"
      itinerary_sensor: "{{ itinerary_sensors[idx] }}"

  # If the user is currently at home
  - if:
      - condition: template
        value_template: "{{ is_state(person, 'home') }}"
    then:
      #####################
      # OPEN GATE ON EXIT #
      #####################

      # Set the user itinerary text variable to "leaving", because the user is leaving home
      - service: input_text.set_value
        target:
          entity_id: "{{ itinerary_sensor }}"
        data:
          value: leaving
      # If iBeacon automatic closing is enabled
      - if:
          - condition: template
            value_template: "{{ ble_entities != [] }}"
        then:
          # Activate the BLE transmitter on the user's phone, to close the gate when he has left
          - service: "{{ notify_device }}"
            data:
              message: command_ble_transmitter
              data:
                command: turn_on
          - if:
              - condition: template
                value_template: "{{ ble_scanner_switch != '' }}"
            then:
              # Activate the BLE scanner from the ESP32 connected to the gate
              - service: switch.turn_on
                target:
                  entity_id: !input ble_scanner_switch
      # If the gate is closing/closed
      - if:
          - condition: template
            value_template: "{{ is_state(gate, ['off', 'closed', 'closing']) }}"
        # Then open it because the user is leaving
        then:
          # Select the right service by checking the first letter of the gate id
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ states[gate].domain == 'switch' }}"
                sequence:
                  - service: switch.turn_on
                    target:
                      entity_id: !input gate
              - conditions:
                  - condition: template
                    value_template: "{{ states[gate].domain == 'cover' }}"
                sequence:
                  - service: cover.open_cover
                    target:
                      entity_id: !input gate
      # Wait for the gate to be closed by the user, or the iBeacon to be out of reach for 20s, or the vehicle to be left, or the user to leave home, all while not waiting more than the auto-close delay
      - wait_for_trigger:
          - platform: template
            id: manual
            value_template: "{{ is_state(gate, ['off', 'closed', 'closing']) }}"
          - platform: template
            id: ble
            value_template: "{{ ble_entities != [] and is_state(ble_entities[idx], 'unknown') }}"
          - platform: template
            id: vehicle_left
            value_template: "{{ is_state(driving_sensor, 'off') }}"
          - platform: template
            id: home_left
            value_template: "{{ not is_state(person, 'home') }}"
        timeout:
          minutes: !input safety_delay
      # Remove the current itinerary since the user has either left home or took too long
      - service: input_text.set_value
        target:
          entity_id: "{{ itinerary_sensor }}"
        data:
          value: none
      # If iBeacon automatic closing is enabled
      - if:
          - condition: template
            value_template: "{{ ble_entities != [] }}"
        then:
          # Deactivate the BLE transmitter on user's phone
          - service: "{{ notify_device }}"
            data:
              message: command_ble_transmitter
              data:
                command: turn_off
      # If the gate has been closed manually
      - if:
          - condition: template
            value_template: "{{ wait.trigger.id == 'manual' }}"
        then:
          # If the iBeacon scanner is only managed by this automation, and doesn't need to stay on
          - if:
              - condition: template
                value_template: "{{ ble_scanner_switch != '' }}"
            then:
              # Deactivate the BLE scanner from the ESP32 connected to the gate (optional)
              - service: switch.turn_off
                target:
                  entity_id: !input ble_scanner_switch
        else:
          # If no one else is currently leaving the house
          - if:
              - condition: not
                conditions:
                  - condition: template
                    value_template: "{{ driving_sensors | select('is_state', 'leaving') | list != [] }}"
            then:
              # If the iBeacon scanner is only managed by this automation, and doesn't need to stay on
              - if:
                  - condition: template
                    value_template: "{{ ble_scanner_switch != '' }}"
                then:
                  # Deactivate the BLE scanner from the ESP32 connected to the gate (optional)
                  - service: switch.turn_off
                    target:
                      entity_id: !input ble_scanner_switch
              # If no one else is currently approaching the house
              - if:
                  - condition: not
                    conditions:
                      - condition: template
                        value_template: "{{ driving_sensors | select('is_state', 'on_approach') | list != [] }}"
                then:
                  # If the timeout was reached
                  - if:
                      - condition: template
                        value_template: "{{ wait.completed }}"
                    then:
                      # Notify the user that the gate will close automatically since he didn't leave in time
                      - service: "{{ notify_device }}"
                        data:
                          title: !input gate_closing_title
                          message: !input did_not_leave_message
                          data:
                            car_ui: true
                            notification_icon: mdi:alert-circle
                            channel: Gate alerts
                            importance: high
                            tag: automatic-closing
                            timeout: 300
                    else:
                      # Notify the user that the gate will close automatically
                      - service: "{{ notify_device }}"
                        data:
                          message: !input automatic_closing_message
                          data:
                            car_ui: true
                            notification_icon: mdi:gate
                            channel: Gate alerts
                            importance: high
                            tag: automatic-closing
                            timeout: 300
                  # Close the gate
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ states[gate].domain == 'switch' }}"
                        sequence:
                          - service: switch.turn_off
                            target:
                              entity_id: !input gate
                      - conditions:
                          - condition: template
                            value_template: "{{ states[gate].domain == 'cover' }}"
                        sequence:
                          - service: cover.close_cover
                            target:
                              entity_id: !input gate
                  # Remove the notification received by the user when his itinerary was started
                  - service: "{{ notify_device }}"
                    data:
                      message: clear_notification
                      data:
                        tag: itinerary
                  # Stop the whole script as it ran successfully
                  - stop: Successful
          # Get the names of the persons being awaited
          - variables:
              awaiting_sensors: >-
                {{ (itinerary_sensors | select('is_state', 'on_approach') | list +
                    itinerary_sensors | select('is_state', 'leaving') | list) }}
              awaiting_persons: >-
                {% set data = namespace(awaiting_persons=[]) %}
                {% for i in range(awaiting_sensors|length) %}
                {% set data.awaiting_persons = data.awaiting_persons + [state_attr(persons[i], 'friendly_name')] %}
                {% endfor %}
                {{ data.awaiting_persons | join(', ') }}
          # Notify the user that the gate will wait for next person
          - service: "{{ notify_device }}"
            data:
              title: !input awaiting_title
              message: !input awaiting_message
              data:
                car_ui: true
                notification_icon: mdi:sleep
                channel: Gate alerts
                importance: high
                tag: itinerary
          # Wait for the gate to be closed
          - wait_for_trigger:
              - platform: template
                value_template: "{{ is_state(gate, ['off', 'closed', 'closing']) }}"
      # Remove the notification received by the user when his itinerary was started or while the gate was awaiting another user
      - service: "{{ notify_device }}"
        data:
          message: clear_notification
          data:
            tag: itinerary

    ###################
    # START ITINERARY #
    ###################

    # If the user is currently away from home
    else:
      # Set the user itinerary text variable to "arriving", because the user has entered a vehicle away from home
      - service: input_text.set_value
        target:
          entity_id: "{{ itinerary_sensor }}"
        data:
          value: arriving
      # Notify the user that his itinerary has been started
      - service: "{{ notify_device }}"
        data:
          title: !input itinerary_update_title
          message: !input itinerary_started_message
          data:
            car_ui: true
            notification_icon: mdi:map-check
            channel: Gate alerts
            importance: high
            tag: itinerary
      # If the travel time refresh rate is set to "While near home"
      - if:
          - condition: template
            value_template: "{{ travel_time_rate == 'While near home' }}"
        # Then update the user travel time once to display an approximation on the dashboard (while taking into account the time elapsed
        then:
          - service: homeassistant.update_entity
            target:
              entity_id: "{{ travel_time_sensor }}"
      # Repeat while the user is driving
      - repeat:
          while:
            - condition: template
              value_template: "{{ is_state(driving_sensor, 'on') }}"
          sequence:
            # If the travel time has expired and its refresh rate is set to "Continuously"
            - if:
                - condition: template
                  value_template: "{{ travel_time_rate == 'Continuously' and
                    states[travel_time_sensor].last_updated + timedelta(minutes=1) < now() }}"
              # Then refresh the travel time to display a precise value on the dashboard
              then:
                - service: homeassistant.update_entity
                  target:
                    entity_id: "{{ travel_time_sensor }}"
            # Wait for a user position update or a deactivation of his driving sensor
            - wait_for_trigger:
                - platform: event
                  event_type: state_changed
                  event_data:
                    entity_id: "{{ person }}"
                - platform: template
                  value_template: "{{ is_state(driving_sensor, 'off') }}"
            # Repeat while the user is nearer than 1km of radius from home and is still driving
            # This allows to update to a precise ETA even if a traffic jam appears near home
            # It will return to the previous loop if the user has entered the radius but passed by and didn't go directly to home
            - repeat:
                while:
                  - condition: template
                    value_template: "{{ states(proximity_sensors[idx]) | int < eta_zone }}"
                  - condition: template
                    value_template: "{{ is_state(driving_sensor, 'on') }}"
                sequence:
                  # Update the user travel time when there is a new position
                  - service: homeassistant.update_entity
                    target:
                      entity_id: "{{ travel_time_sensor }}"
                  # Verify that your integration has responded with a new travel time
                  - condition: template
                    value_template: "{{ states[travel_time_sensor].last_updated > now() - timedelta(seconds=5) }}"
                  # Calculate his Estimated Time of Arrival
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: !input eta_sensor
                    data:
                      datetime: >
                        {{ (as_timestamp(now()) +
                        (state_attr(travel_time_sensor, 'duration') | float *
                        60) - lead_time) | timestamp_custom('%Y-%m-%d %H:%M:%S') }}
                  # If the ETA is in the future
                  - if:
                      - condition: template
                        value_template: "{{ state_attr(eta_sensor, 'timestamp') > as_timestamp(now()) }}"
                    then:
                      # If the travel time refresh rate is set to "Once when near home"
                      - if:
                          - condition: template
                            value_template: "{{ travel_time_rate == 'Once when near home' }}"
                        # Then wait for ETA or car left
                        then:
                          - wait_for_trigger:
                              - platform: time
                                at: !input eta_sensor
                              - platform: template
                                value_template: "{{ is_state(driving_sensor, 'off') }}"
                        # If the travel time refresh rate is set to "Continuously" or "While near home"
                        else:
                          # Wait for ETA or new position or car left, and cancel if it hasn't been updated for too long (e.g: if device offline)
                          - wait_for_trigger:
                              - platform: event
                                event_type: state_changed
                                event_data:
                                  entity_id: "{{ person }}"
                              - platform: time
                                at: !input eta_sensor
                              - platform: template
                                value_template: "{{ is_state(driving_sensor, 'off') }}"
                            timeout:
                              minutes: !input timeout_delay
                          # If the timeout ran out of time
                          - if:
                              - condition: template
                                value_template: "{{ wait.completed }}"
                            then:
                              # Remove the current itinerary since the user has timed out
                              - service: input_text.set_value
                                target:
                                  entity_id: "{{ itinerary_sensor }}"
                                data:
                                  value: none
                              # Notify the user that his itinerary has been canceled
                              - service: "{{ notify_device }}"
                                data:
                                  title: !input itinerary_canceled_title
                                  message: !input timed_out_message
                                  data:
                                    car_ui: true
                                    notification_icon: mdi:alert-circle
                                    channel: Gate alerts
                                    importance: high
                                    tag: itinerary
                                    timeout: 300
                              - stop: Timed out

                  # Restart the second repeat loop if the wait_for_trigger was triggered by a position or car sensor update
                  # This allows the loop to refresh the ETA with a new position or stop the script if the car was left
                  # This is quite a redundant condition as it has already been checked above, if you find a better way to restart the loop, feel free to make a PR
                  - condition: template
                    value_template: "{{ state_attr(eta_sensor, 'timestamp') <= as_timestamp(now()) }}"
                  - if:
                      # The user is not in the activation zone
                      - condition: template
                        value_template: "{{ states(proximity_sensors[idx]) | int > activation_zone }}"
                    then:
                      # Remove the current itinerary since the user was not in the activation zone when the gate tried to open
                      - service: input_text.set_value
                        target:
                          entity_id: "{{ itinerary_sensor }}"
                        data:
                          value: none
                      # Notify the user that his itinerary has been canceled
                      - service: "{{ notify_device }}"
                        data:
                          title: !input itinerary_canceled_title
                          message: !input vehicle_away_message
                          data:
                            car_ui: true
                            notification_icon: mdi:alert-circle
                            channel: Gate alerts
                            importance: high
                            tag: itinerary
                            timeout: 300
                      - stop: Not in activation zone
                  # Set the user itinerary text variable to "on_approach", because the user is near the house and will arrive soon
                  - service: input_text.set_value
                    data:
                      value: on_approach
                    target:
                      entity_id: "{{ itinerary_sensor }}"
                  # If the gate is closing/closed
                  - if:
                      - condition: template
                        value_template: "{{ is_state(gate, ['off', 'closed', 'closing']) }}"
                    # Then open it
                    then:
                      # Select the right service by checking the first letter of the gate id
                      - choose:
                          - conditions:
                              - condition: template
                                value_template: "{{ states[gate].domain == 'switch' }}"
                            sequence:
                              - service: switch.turn_on
                                target:
                                  entity_id: !input gate
                          - conditions:
                              - condition: template
                                value_template: "{{ states[gate].domain == 'cover' }}"
                            sequence:
                              - service: cover.open_cover
                                target:
                                  entity_id: !input gate
                  # Wait for the gate to be closed manually, or the vehicle to be left, or the user to leave the activation zone, all while not waiting more than the auto-close delay
                  - wait_for_trigger:
                      - platform: template
                        id: manual
                        value_template: "{{ is_state(gate, ['off', 'closed', 'closing']) }}"
                      - platform: template
                        id: vehicle_left
                        value_template: "{{ is_state(driving_sensor, 'off') }}"
                      - platform: template
                        id: zone_left
                        value_template: "{{ states(proximity_sensors[idx]) | int > activation_zone }}"
                    timeout:
                      minutes: !input safety_delay
                  # Remove the current itinerary since the user has either arrived home or took too long
                  - service: input_text.set_value
                    target:
                      entity_id: "{{ itinerary_sensor }}"
                    data:
                      value: none
                  # If the gate has been closed manually
                  - if:
                      - condition: template
                        value_template: "{{ wait.trigger.id == 'manual' }}"
                    then:
                      # Remove the notification received by the user when his itinerary was started
                      - service: "{{ notify_device }}"
                        data:
                          message: clear_notification
                          data:
                            tag: itinerary
                    else:
                      # If someone is currently approaching or leaving the house
                      - if:
                          - condition: or
                            conditions:
                              - condition: template
                                value_template: "{{ driving_sensors | select('is_state', 'on_approach') | list != [] }}"
                              - condition: template
                                value_template: "{{ driving_sensors | select('is_state', 'leaving') | list != [] }}"
                        then:
                          # Get the names of the persons being awaited
                          - variables:
                              awaiting_sensors: >-
                                {{ (itinerary_sensors | select('is_state', 'on_approach') | list +
                                    itinerary_sensors | select('is_state', 'leaving') | list) }}
                              awaiting_persons: >-
                                {% set data = namespace(awaiting_persons=[]) %}
                                {% for i in range(awaiting_sensors|length) %}
                                {% set data.awaiting_persons = data.awaiting_persons + [state_attr(persons[i], 'friendly_name')] %}
                                {% endfor %}
                                {{ data.awaiting_persons | join(', ') }}
                          # Notify the user that the gate will wait for next person
                          - service: "{{ notify_device }}"
                            data:
                              title: !input awaiting_title
                              message: !input awaiting_message
                              data:
                                car_ui: true
                                notification_icon: mdi:sleep
                                channel: Gate alerts
                                importance: high
                                tag: itinerary
                          # Wait for the gate to be closed
                          - wait_for_trigger:
                              - platform: template
                                value_template: "{{ is_state(gate, ['off', 'closed', 'closing']) }}"
                        # If no one is currently approaching or leaving the house
                        else:
                          - choose:
                              # If the timeout was reached
                              - conditions:
                                  - condition: template
                                    value_template: "{{ wait.completed }}"
                                sequence:
                                  # Notify the user that the gate will close automatically since he took too long
                                  - service: "{{ notify_device }}"
                                    data:
                                      title: !input gate_closing_title
                                      message: !input did_not_arrive_message
                                      data:
                                        car_ui: true
                                        notification_icon: mdi:alert-circle
                                        channel: Gate alerts
                                        importance: high
                                        tag: automatic-closing
                                        timeout: 300
                              # If the user has exited the gate activation zone
                              - conditions:
                                  - condition: template
                                    value_template: "{{ wait.trigger.id == 'zone_left' }}"
                                sequence:
                                  # Notify the user that the gate will close automatically since he has exited the zone
                                  - service: "{{ notify_device }}"
                                    data:
                                      title: !input gate_closing_title
                                      message: !input vehicle_away_message
                                      data:
                                        car_ui: true
                                        notification_icon: mdi:alert-circle
                                        channel: Gate alerts
                                        importance: high
                                        tag: automatic-closing
                                        timeout: 300
                              # If the user has left his car
                              - conditions:
                                  - condition: template
                                    value_template: "{{ wait.trigger.id == 'vehicle_left' }}"
                                sequence:
                                  # Notify the user that the gate will close automatically since he has left his car
                                  - service: "{{ notify_device }}"
                                    data:
                                      title: !input gate_closing_title
                                      message: !input vehicle_left_message
                                      data:
                                        car_ui: true
                                        notification_icon: mdi:alert-circle
                                        channel: Gate alerts
                                        importance: high
                                        tag: automatic-closing
                                        timeout: 300
                            default:
                              # Notify the user that the gate will close automatically
                              - service: "{{ notify_device }}"
                                data:
                                  message: !input automatic_closing_message
                                  data:
                                    car_ui: true
                                    notification_icon: mdi:gate
                                    channel: Gate alerts
                                    importance: high
                                    tag: automatic-closing
                                    timeout: 300
                          # Close the gate
                          - choose:
                              - conditions:
                                  - condition: template
                                    value_template: "{{ states[gate].domain == 'switch' }}"
                                sequence:
                                  - service: switch.turn_off
                                    target:
                                      entity_id: !input gate
                              - conditions:
                                  - condition: template
                                    value_template: "{{ states[gate].domain == 'cover' }}"
                                sequence:
                                  - service: cover.close_cover
                                    target:
                                      entity_id: !input gate
                  # Remove the notification received by the user when his itinerary was started or awaiting next user
                  - service: "{{ notify_device }}"
                    data:
                      message: clear_notification
                      data:
                        tag: itinerary
                  # Stop the whole script as it was successful
                  - stop: Successful
      # If both loop were broken
      # Remove the current itinerary since the user has left his vehicle or timed out
      - service: input_text.set_value
        data:
          value: none
        target:
          entity_id: "{{ itinerary_sensor }}"
      # Notify the user that his itinerary has been canceled
      - service: "{{ notify_device }}"
        data:
          title: !input itinerary_canceled_title
          message: !input vehicle_left_message
          data:
            car_ui: true
            notification_icon: mdi:alert-circle
            channel: Gate alerts
            importance: high
            tag: itinerary
            timeout: 300
# Run in parralel to let the automation start with multiple users driving simultaneously
mode: parallel
max: 10
